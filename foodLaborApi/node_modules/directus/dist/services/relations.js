"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RelationsService = void 0;
const items_1 = require("./items");
const permissions_1 = require("./permissions");
const to_array_1 = require("../utils/to-array");
const relations_1 = require("../database/system-data/relations");
const exceptions_1 = require("../exceptions");
const logger_1 = __importDefault(require("../logger"));
class RelationsService extends items_1.ItemsService {
    constructor(options) {
        super('directus_relations', options);
        this.permissionsService = new permissions_1.PermissionsService(options);
    }
    /**
     * Read multiple relations by query.
     *
     * Note: this is based on permissions access to other collections/fields, not permissions to
     * directus_relations directly
     */
    readByQuery(query, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new items_1.ItemsService('directus_relations', {
                knex: this.knex,
                schema: this.schema,
                // We don't set accountability here. If you have read access to certain fields, you are
                // allowed to extract the relations regardless of permissions to directus_relations. This
                // happens in `filterForbidden` down below
            });
            const results = yield service.readByQuery(query, opts);
            results.push(...relations_1.systemRelationRows);
            const filteredResults = yield this.filterForbidden(results);
            return filteredResults;
        });
    }
    /**
     * Get a single relations row by key. This is based on your permissions to the collections/fields
     * involved in the relation, not permissions to directus_relations
     */
    readOne(key, query, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new items_1.ItemsService('directus_relations', {
                knex: this.knex,
                schema: this.schema,
                // We don't set accountability here. If you have read access to certain fields, you are
                // allowed to extract the relations regardless of permissions to directus_relations. This
                // happens in `filterForbidden` down below
            });
            const result = yield service.readOne(key, query, opts);
            // No need to merge system relations here. They don't have PKs so can never be directly
            // targeted
            const filteredResults = yield this.filterForbidden([result]);
            if (filteredResults.length === 1)
                return filteredResults[0];
            throw new exceptions_1.ForbiddenException();
        });
    }
    /**
     * Get a single relations row by key. This is based on your permissions to the collections/fields
     * involved in the relation, not permissions to directus_relations
     */
    readMany(keys, query, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = new items_1.ItemsService('directus_relations', {
                knex: this.knex,
                schema: this.schema,
                // We don't set accountability here. If you have read access to certain fields, you are
                // allowed to extract the relations regardless of permissions to directus_relations. This
                // happens in `filterForbidden` down below
            });
            const result = yield service.readMany(keys, query, opts);
            // No need to merge system relations here. They don't have PKs so can never be directly
            // targeted
            const filteredResults = yield this.filterForbidden(result);
            if (filteredResults.length === 0)
                throw new exceptions_1.ForbiddenException();
            return filteredResults;
        });
    }
    /**
     * Loop over all relations and filter out the ones that contain collections/fields you don't have
     * permissions to
     */
    filterForbidden(relations) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.accountability === null || ((_a = this.accountability) === null || _a === void 0 ? void 0 : _a.admin) === true)
                return relations;
            const allowedCollections = this.schema.permissions
                .filter((permission) => {
                return permission.action === 'read';
            })
                .map(({ collection }) => collection);
            const allowedFields = this.permissionsService.getAllowedFields('read');
            relations = to_array_1.toArray(relations);
            return relations.filter((relation) => {
                let collectionsAllowed = true;
                let fieldsAllowed = true;
                if (allowedCollections.includes(relation.many_collection) === false) {
                    collectionsAllowed = false;
                }
                if (relation.one_collection && allowedCollections.includes(relation.one_collection) === false) {
                    collectionsAllowed = false;
                }
                if (relation.one_allowed_collections &&
                    relation.one_allowed_collections.every((collection) => allowedCollections.includes(collection)) === false) {
                    collectionsAllowed = false;
                }
                if (!allowedFields[relation.many_collection] ||
                    (allowedFields[relation.many_collection].includes('*') === false &&
                        allowedFields[relation.many_collection].includes(relation.many_field) === false)) {
                    fieldsAllowed = false;
                }
                if (relation.one_collection &&
                    relation.one_field &&
                    (!allowedFields[relation.one_collection] ||
                        (allowedFields[relation.one_collection].includes('*') === false &&
                            allowedFields[relation.one_collection].includes(relation.one_field) === false))) {
                    fieldsAllowed = false;
                }
                return collectionsAllowed && fieldsAllowed;
            });
        });
    }
    readByKey(key, query = {}, action = 'read') {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.warn('RelationsService.readByKey is deprecated and will be removed before v9.0.0. Use readOne or readMany instead.');
            if (Array.isArray(key))
                return yield this.readMany(key, query, { permissionsAction: action });
            return yield this.readOne(key, query, { permissionsAction: action });
        });
    }
}
exports.RelationsService = RelationsService;
