"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionsService = void 0;
const constants_1 = require("../constants");
const database_1 = __importStar(require("../database"));
const exceptions_1 = require("../exceptions");
const fields_1 = require("../services/fields");
const items_1 = require("../services/items");
const cache_1 = __importDefault(require("../cache"));
const collections_1 = require("../database/system-data/collections");
const env_1 = __importDefault(require("../env"));
const logger_1 = __importDefault(require("../logger"));
class CollectionsService {
    constructor(options) {
        this.knex = options.knex || database_1.default;
        this.accountability = options.accountability || null;
        this.schema = options.schema;
    }
    /**
     * Create a single new collection
     */
    createOne(payload, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.accountability && this.accountability.admin !== true) {
                throw new exceptions_1.ForbiddenException('Only admins can perform this action.');
            }
            if (!payload.collection)
                throw new exceptions_1.InvalidPayloadException(`"collection" is required`);
            if (!payload.fields)
                payload.fields = [];
            // Ensure that every field meta has the field/collection fields filled correctly
            payload.fields = payload.fields.map((field) => {
                if (field.meta) {
                    field.meta = Object.assign(Object.assign({}, field.meta), { field: field.field, collection: payload.collection });
                }
                return field;
            });
            // Create the collection/fields in a transaction so it'll be reverted in case of errors or
            // permission problems. This might not work reliably in MySQL, as it doesn't support DDL in
            // transactions.
            yield this.knex.transaction((trx) => __awaiter(this, void 0, void 0, function* () {
                const fieldsService = new fields_1.FieldsService({ knex: trx, schema: this.schema });
                // This operation is locked to admin users only, so we don't have to worry about the order
                // of operations here with regards to permissions checks
                const collectionItemsService = new items_1.ItemsService('directus_collections', {
                    knex: trx,
                    accountability: this.accountability,
                    schema: this.schema,
                });
                const fieldItemsService = new items_1.ItemsService('directus_fields', {
                    knex: trx,
                    accountability: this.accountability,
                    schema: this.schema,
                });
                if (payload.collection.startsWith('directus_')) {
                    throw new exceptions_1.InvalidPayloadException(`Collections can't start with "directus_"`);
                }
                if (payload.collection in this.schema.collections) {
                    throw new exceptions_1.InvalidPayloadException(`Collection "${payload.collection}" already exists.`);
                }
                yield trx.schema.createTable(payload.collection, (table) => {
                    for (const field of payload.fields) {
                        if (field.type && constants_1.ALIAS_TYPES.includes(field.type) === false) {
                            fieldsService.addColumnToTable(table, field);
                        }
                    }
                });
                yield collectionItemsService.createOne(Object.assign(Object.assign({}, (payload.meta || {})), { collection: payload.collection }));
                const fieldPayloads = payload.fields.filter((field) => field.meta).map((field) => field.meta);
                yield fieldItemsService.createMany(fieldPayloads);
                return payload.collection;
            }));
            if (cache_1.default && env_1.default.CACHE_AUTO_PURGE && (opts === null || opts === void 0 ? void 0 : opts.autoPurgeCache) !== false) {
                yield cache_1.default.clear();
            }
            return payload.collection;
        });
    }
    /**
     * Create multiple new collections
     */
    createMany(payloads, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const collections = yield this.knex.transaction((trx) => __awaiter(this, void 0, void 0, function* () {
                const service = new CollectionsService({
                    schema: this.schema,
                    accountability: this.accountability,
                    knex: trx,
                });
                const collectionNames = [];
                for (const payload of payloads) {
                    const name = yield service.createOne(payload, { autoPurgeCache: false });
                    collectionNames.push(name);
                }
                return collectionNames;
            }));
            if (cache_1.default && env_1.default.CACHE_AUTO_PURGE && (opts === null || opts === void 0 ? void 0 : opts.autoPurgeCache) !== false) {
                yield cache_1.default.clear();
            }
            return collections;
        });
    }
    /**
     * Read all collections. Currently doesn't support any query.
     */
    readByQuery() {
        return __awaiter(this, void 0, void 0, function* () {
            const collectionItemsService = new items_1.ItemsService('directus_collections', {
                knex: this.knex,
                schema: this.schema,
                accountability: this.accountability,
            });
            let tablesInDatabase = yield database_1.schemaInspector.tableInfo();
            if (this.accountability && this.accountability.admin !== true) {
                const collectionsYouHavePermissionToRead = this.schema.permissions
                    .filter((permission) => {
                    return permission.action === 'read';
                })
                    .map(({ collection }) => collection);
                tablesInDatabase = tablesInDatabase.filter((table) => {
                    return collectionsYouHavePermissionToRead.includes(table.name);
                });
            }
            const tablesToFetchInfoFor = tablesInDatabase.map((table) => table.name);
            const meta = (yield collectionItemsService.readByQuery({
                filter: { collection: { _in: tablesToFetchInfoFor } },
                limit: -1,
            }));
            meta.push(...collections_1.systemCollectionRows);
            const collections = [];
            for (const table of tablesInDatabase) {
                const collection = {
                    collection: table.name,
                    meta: meta.find((systemInfo) => (systemInfo === null || systemInfo === void 0 ? void 0 : systemInfo.collection) === table.name) || null,
                    schema: table,
                };
                collections.push(collection);
            }
            return collections;
        });
    }
    /**
     * Get a single collection by name
     */
    readOne(collectionKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.readMany([collectionKey]);
            return result[0];
        });
    }
    /**
     * Read many collections by name
     */
    readMany(collectionKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            const collectionItemsService = new items_1.ItemsService('directus_collections', {
                knex: this.knex,
                accountability: this.accountability,
                schema: this.schema,
            });
            if (this.accountability && this.accountability.admin !== true) {
                const permissions = this.schema.permissions.filter((permission) => {
                    return permission.action === 'read' && collectionKeys.includes(permission.collection);
                });
                if (collectionKeys.length !== permissions.length) {
                    const collectionsYouHavePermissionToRead = permissions.map(({ collection }) => collection);
                    for (const collectionKey of collectionKeys) {
                        if (collectionsYouHavePermissionToRead.includes(collectionKey) === false) {
                            throw new exceptions_1.ForbiddenException(`You don't have access to the "${collectionKey}" collection.`);
                        }
                    }
                }
            }
            const tablesInDatabase = yield database_1.schemaInspector.tableInfo();
            const tables = tablesInDatabase.filter((table) => collectionKeys.includes(table.name));
            const meta = (yield collectionItemsService.readByQuery({
                filter: { collection: { _in: collectionKeys } },
                limit: -1,
            }));
            meta.push(...collections_1.systemCollectionRows);
            const collections = [];
            for (const table of tables) {
                const collection = {
                    collection: table.name,
                    meta: meta.find((systemInfo) => (systemInfo === null || systemInfo === void 0 ? void 0 : systemInfo.collection) === table.name) || null,
                    schema: table,
                };
                collections.push(collection);
            }
            return collections;
        });
    }
    /**
     * Update a single collection by name
     *
     * Note: only supports updating `meta`
     */
    updateOne(collectionKey, data, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.accountability && this.accountability.admin !== true) {
                throw new exceptions_1.ForbiddenException('Only admins can perform this action.');
            }
            const collectionItemsService = new items_1.ItemsService('directus_collections', {
                knex: this.knex,
                accountability: this.accountability,
                schema: this.schema,
            });
            const payload = data;
            if (!payload.meta) {
                throw new exceptions_1.InvalidPayloadException(`"meta" key is required`);
            }
            const exists = !!(yield this.knex
                .select('collection')
                .from('directus_collections')
                .where({ collection: collectionKey })
                .first());
            if (exists) {
                yield collectionItemsService.updateOne(collectionKey, payload.meta, opts);
            }
            else {
                yield collectionItemsService.createOne(Object.assign(Object.assign({}, payload.meta), { collection: collectionKey }), opts);
            }
            return collectionKey;
        });
    }
    /**
     * Update multiple collections by name
     */
    updateMany(collectionKeys, data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.accountability && this.accountability.admin !== true) {
                throw new exceptions_1.ForbiddenException('Only admins can perform this action.');
            }
            yield this.knex.transaction((trx) => __awaiter(this, void 0, void 0, function* () {
                const service = new CollectionsService({
                    schema: this.schema,
                    accountability: this.accountability,
                    knex: trx,
                });
                for (const collectionKey of collectionKeys) {
                    yield service.updateOne(collectionKey, data, { autoPurgeCache: false });
                }
            }));
            return collectionKeys;
        });
    }
    /**
     * Delete a single collection This will delete the table and all records within. It'll also
     * delete any fields, presets, activity, revisions, and permissions relating to this collection
     */
    deleteOne(collectionKey, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.accountability && this.accountability.admin !== true) {
                throw new exceptions_1.ForbiddenException('Only admins can perform this action.');
            }
            const collectionItemsService = new items_1.ItemsService('directus_collections', {
                knex: this.knex,
                accountability: this.accountability,
                schema: this.schema,
            });
            const fieldsService = new fields_1.FieldsService({
                knex: this.knex,
                accountability: this.accountability,
                schema: this.schema,
            });
            const tablesInDatabase = Object.keys(this.schema.collections);
            if (tablesInDatabase.includes(collectionKey) === false) {
                throw new exceptions_1.ForbiddenException();
            }
            yield collectionItemsService.deleteOne(collectionKey);
            yield this.knex('directus_fields').delete().where('collection', '=', collectionKey);
            yield this.knex('directus_presets').delete().where('collection', '=', collectionKey);
            yield this.knex('directus_revisions').delete().where('collection', '=', collectionKey);
            yield this.knex('directus_activity').delete().where('collection', '=', collectionKey);
            yield this.knex('directus_permissions').delete().where('collection', '=', collectionKey);
            const relations = this.schema.relations.filter((relation) => {
                return relation.many_collection === collectionKey || relation.one_collection === collectionKey;
            });
            for (const relation of relations) {
                const isM2O = relation.many_collection === collectionKey;
                if (isM2O) {
                    yield this.knex('directus_relations')
                        .delete()
                        .where({ many_collection: collectionKey, many_field: relation.many_field });
                    yield fieldsService.deleteField(relation.one_collection, relation.one_field);
                }
                else if (!!relation.one_collection) {
                    yield this.knex('directus_relations')
                        .update({ one_field: null })
                        .where({ one_collection: collectionKey, one_field: relation.one_field });
                    yield fieldsService.deleteField(relation.many_collection, relation.many_field);
                }
            }
            yield this.knex.schema.dropTable(collectionKey);
            if (cache_1.default && env_1.default.CACHE_AUTO_PURGE && (opts === null || opts === void 0 ? void 0 : opts.autoPurgeCache) !== false) {
                yield cache_1.default.clear();
            }
            return collectionKey;
        });
    }
    /**
     * Delete multiple collections by key
     */
    deleteMany(collectionKeys, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.accountability && this.accountability.admin !== true) {
                throw new exceptions_1.ForbiddenException('Only admins can perform this action.');
            }
            yield this.knex.transaction((trx) => __awaiter(this, void 0, void 0, function* () {
                const service = new CollectionsService({
                    schema: this.schema,
                    accountability: this.accountability,
                    knex: trx,
                });
                for (const collectionKey of collectionKeys) {
                    yield service.deleteOne(collectionKey, { autoPurgeCache: false });
                }
            }));
            if (cache_1.default && env_1.default.CACHE_AUTO_PURGE && (opts === null || opts === void 0 ? void 0 : opts.autoPurgeCache) !== false) {
                yield cache_1.default.clear();
            }
            return collectionKeys;
        });
    }
    create(data) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.warn('CollectionsService.create is deprecated and will be removed before v9.0.0. Use createOne or createMany instead.');
            if (Array.isArray(data)) {
                return yield this.createMany(data);
            }
            else {
                return yield this.createOne(data);
            }
        });
    }
    readByKey(collection) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.warn('CollectionsService.readByKey is deprecated and will be removed before v9.0.0. Use readOne or readMany instead.');
            if (Array.isArray(collection))
                return yield this.readMany(collection);
            return yield this.readOne(collection);
        });
    }
    update(data, key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Array.isArray(key))
                return yield this.updateMany(key, data);
            return yield this.updateOne(key, data);
        });
    }
    delete(collection) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.warn('CollectionsService.delete is deprecated and will be removed before v9.0.0. Use deleteOne or deleteMany instead.');
            if (Array.isArray(collection))
                return yield this.deleteMany(collection);
            return yield this.deleteOne(collection);
        });
    }
}
exports.CollectionsService = CollectionsService;
