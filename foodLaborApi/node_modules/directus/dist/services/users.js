"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UsersService = void 0;
const authentication_1 = require("./authentication");
const items_1 = require("./items");
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const mail_1 = require("../mail");
const database_1 = __importDefault(require("../database"));
const argon2_1 = __importDefault(require("argon2"));
const exceptions_1 = require("../exceptions");
const env_1 = __importDefault(require("../env"));
const cache_1 = __importDefault(require("../cache"));
const to_array_1 = require("../utils/to-array");
const record_not_unique_1 = require("../exceptions/database/record-not-unique");
const logger_1 = __importDefault(require("../logger"));
const lodash_1 = require("lodash");
class UsersService extends items_1.ItemsService {
    constructor(options) {
        super('directus_users', options);
        this.knex = options.knex || database_1.default;
        this.accountability = options.accountability || null;
        this.service = new items_1.ItemsService('directus_users', options);
        this.schema = options.schema;
    }
    /**
     * User email has to be unique case-insensitive. This is an additional check to make sure that
     * the email is unique regardless of casing
     */
    checkUniqueEmails(emails) {
        return __awaiter(this, void 0, void 0, function* () {
            if (emails.length > 0) {
                const results = yield this.knex
                    .select('email')
                    .from('directus_users')
                    .whereRaw(`LOWER(??) IN (${emails.map(() => '?')})`, ['email', ...emails]);
                if (results.length > 0) {
                    throw new record_not_unique_1.RecordNotUniqueException('email', {
                        collection: 'directus_users',
                        field: 'email',
                        invalid: results[0].email,
                    });
                }
            }
        });
    }
    /**
     * Create a new user
     */
    createOne(data, opts) {
        const _super = Object.create(null, {
            createOne: { get: () => super.createOne }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const email = data.email.toLowerCase();
            yield this.checkUniqueEmails([email]);
            return yield _super.createOne.call(this, data, opts);
        });
    }
    /**
     * Create multiple new users
     */
    createMany(data, opts) {
        const _super = Object.create(null, {
            createMany: { get: () => super.createMany }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const emails = data
                .map((payload) => payload.email)
                .filter((e) => e)
                .map((e) => e.toLowerCase());
            yield this.checkUniqueEmails(emails);
            return yield _super.createMany.call(this, data, opts);
        });
    }
    updateOne(key, data, opts) {
        const _super = Object.create(null, {
            updateOne: { get: () => super.updateOne }
        });
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const email = (_a = data.email) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (email) {
                yield this.checkUniqueEmails([email]);
            }
            if (data.hasOwnProperty('tfa_secret')) {
                throw new exceptions_1.InvalidPayloadException(`You can't change the "tfa_secret" value manually.`);
            }
            return yield _super.updateOne.call(this, key, data, opts);
        });
    }
    updateMany(keys, data, opts) {
        const _super = Object.create(null, {
            updateMany: { get: () => super.updateMany }
        });
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const email = (_a = data.email) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (email) {
                yield this.checkUniqueEmails([email]);
            }
            if (data.hasOwnProperty('tfa_secret')) {
                throw new exceptions_1.InvalidPayloadException(`You can't change the "tfa_secret" value manually.`);
            }
            return yield _super.updateMany.call(this, keys, data, opts);
        });
    }
    updateByQuery(query, data, opts) {
        const _super = Object.create(null, {
            updateByQuery: { get: () => super.updateByQuery }
        });
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const email = (_a = data.email) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (email) {
                yield this.checkUniqueEmails([email]);
            }
            if (data.hasOwnProperty('tfa_secret')) {
                throw new exceptions_1.InvalidPayloadException(`You can't change the "tfa_secret" value manually.`);
            }
            return yield _super.updateByQuery.call(this, query, data, opts);
        });
    }
    deleteOne(key, opts) {
        const _super = Object.create(null, {
            deleteOne: { get: () => super.deleteOne }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // Make sure there's at least one admin user left after this deletion is done
            const otherAdminUsers = yield this.knex
                .count('*', { as: 'count' })
                .from('directus_users')
                .whereNot('directus_users.id', key)
                .andWhere({ 'directus_roles.admin_access': true })
                .leftJoin('directus_roles', 'directus_users.role', 'directus_roles.id')
                .first();
            const otherAdminUsersCount = +((otherAdminUsers === null || otherAdminUsers === void 0 ? void 0 : otherAdminUsers.count) || 0);
            if (otherAdminUsersCount === 0) {
                throw new exceptions_1.UnprocessableEntityException(`You can't delete the last admin user.`);
            }
            yield _super.deleteOne.call(this, key, opts);
            return key;
        });
    }
    deleteMany(keys, opts) {
        const _super = Object.create(null, {
            deleteMany: { get: () => super.deleteMany }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // Make sure there's at least one admin user left after this deletion is done
            const otherAdminUsers = yield this.knex
                .count('*', { as: 'count' })
                .from('directus_users')
                .whereNotIn('directus_users.id', keys)
                .andWhere({ 'directus_roles.admin_access': true })
                .leftJoin('directus_roles', 'directus_users.role', 'directus_roles.id')
                .first();
            const otherAdminUsersCount = +((otherAdminUsers === null || otherAdminUsers === void 0 ? void 0 : otherAdminUsers.count) || 0);
            if (otherAdminUsersCount === 0) {
                throw new exceptions_1.UnprocessableEntityException(`You can't delete the last admin user.`);
            }
            yield _super.deleteMany.call(this, keys, opts);
            return keys;
        });
    }
    inviteUser(email, role, url) {
        return __awaiter(this, void 0, void 0, function* () {
            const emails = to_array_1.toArray(email);
            const urlWhitelist = to_array_1.toArray(env_1.default.USER_INVITE_URL_ALLOW_LIST);
            if (url && urlWhitelist.includes(url) === false) {
                throw new exceptions_1.InvalidPayloadException(`Url "${url}" can't be used to invite users.`);
            }
            yield this.knex.transaction((trx) => __awaiter(this, void 0, void 0, function* () {
                const service = new items_1.ItemsService('directus_users', {
                    schema: this.schema,
                    accountability: this.accountability,
                    knex: trx,
                });
                for (const email of emails) {
                    yield service.createOne({ email, role, status: 'invited' });
                    const payload = { email, scope: 'invite' };
                    const token = jsonwebtoken_1.default.sign(payload, env_1.default.SECRET, { expiresIn: '7d' });
                    const inviteURL = url !== null && url !== void 0 ? url : env_1.default.PUBLIC_URL + '/admin/accept-invite';
                    const acceptURL = inviteURL + '?token=' + token;
                    yield mail_1.sendInviteMail(email, acceptURL);
                }
            }));
        });
    }
    acceptInvite(token, password) {
        return __awaiter(this, void 0, void 0, function* () {
            const { email, scope } = jsonwebtoken_1.default.verify(token, env_1.default.SECRET);
            if (scope !== 'invite')
                throw new exceptions_1.ForbiddenException();
            const user = yield this.knex.select('id', 'status').from('directus_users').where({ email }).first();
            if (!user || user.status !== 'invited') {
                throw new exceptions_1.InvalidPayloadException(`Email address ${email} hasn't been invited.`);
            }
            const passwordHashed = yield argon2_1.default.hash(password);
            yield this.knex('directus_users').update({ password: passwordHashed, status: 'active' }).where({ id: user.id });
            if (cache_1.default && env_1.default.CACHE_AUTO_PURGE) {
                yield cache_1.default.clear();
            }
        });
    }
    requestPasswordReset(email, url) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield this.knex.select('id').from('directus_users').where({ email }).first();
            if (!user)
                throw new exceptions_1.ForbiddenException();
            const payload = { email, scope: 'password-reset' };
            const token = jsonwebtoken_1.default.sign(payload, env_1.default.SECRET, { expiresIn: '1d' });
            const urlWhitelist = to_array_1.toArray(env_1.default.PASSWORD_RESET_URL_ALLOW_LIST);
            if (url && urlWhitelist.includes(url) === false) {
                throw new exceptions_1.InvalidPayloadException(`Url "${url}" can't be used to reset passwords.`);
            }
            const acceptURL = url ? `${url}?token=${token}` : `${env_1.default.PUBLIC_URL}/admin/reset-password?token=${token}`;
            yield mail_1.sendPasswordResetMail(email, acceptURL);
        });
    }
    resetPassword(token, password) {
        return __awaiter(this, void 0, void 0, function* () {
            const { email, scope } = jsonwebtoken_1.default.verify(token, env_1.default.SECRET);
            if (scope !== 'password-reset')
                throw new exceptions_1.ForbiddenException();
            const user = yield this.knex.select('id', 'status').from('directus_users').where({ email }).first();
            if (!user || user.status !== 'active') {
                throw new exceptions_1.ForbiddenException();
            }
            const passwordHashed = yield argon2_1.default.hash(password);
            yield this.knex('directus_users').update({ password: passwordHashed, status: 'active' }).where({ id: user.id });
            if (cache_1.default && env_1.default.CACHE_AUTO_PURGE) {
                yield cache_1.default.clear();
            }
        });
    }
    enableTFA(pk) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield this.knex.select('tfa_secret').from('directus_users').where({ id: pk }).first();
            if ((user === null || user === void 0 ? void 0 : user.tfa_secret) !== null) {
                throw new exceptions_1.InvalidPayloadException('TFA Secret is already set for this user');
            }
            const authService = new authentication_1.AuthenticationService({
                knex: this.knex,
                schema: this.schema,
                accountability: this.accountability,
            });
            const secret = authService.generateTFASecret();
            yield this.knex('directus_users').update({ tfa_secret: secret }).where({ id: pk });
            return {
                secret,
                url: yield authService.generateOTPAuthURL(pk, secret),
            };
        });
    }
    disableTFA(pk) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.knex('directus_users').update({ tfa_secret: null }).where({ id: pk });
        });
    }
    create(data) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.warn('UsersService.create is deprecated and will be removed before v9.0.0. Use createOne or createMany instead.');
            if (Array.isArray(data))
                return this.createMany(data);
            return this.createOne(data);
        });
    }
    update(data, key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Array.isArray(key))
                return yield this.updateMany(key, data);
            else if (key)
                yield this.updateOne(key, data);
            const primaryKeyField = this.schema.collections[this.collection].primary;
            const keys = [];
            yield this.knex.transaction((trx) => __awaiter(this, void 0, void 0, function* () {
                const itemsService = new items_1.ItemsService(this.collection, {
                    accountability: this.accountability,
                    knex: trx,
                    schema: this.schema,
                });
                const payloads = to_array_1.toArray(data);
                for (const single of payloads) {
                    const payload = lodash_1.clone(single);
                    const key = payload[primaryKeyField];
                    if (!key) {
                        throw new exceptions_1.InvalidPayloadException('Primary key is missing in update payload.');
                    }
                    keys.push(key);
                    yield itemsService.updateOne(key, payload);
                }
            }));
            return keys;
        });
    }
    delete(key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Array.isArray(key))
                return yield this.deleteMany(key);
            return yield this.deleteOne(key);
        });
    }
}
exports.UsersService = UsersService;
