"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemsService = void 0;
const database_1 = __importDefault(require("../database"));
const run_ast_1 = __importDefault(require("../database/run-ast"));
const get_ast_from_query_1 = __importDefault(require("../utils/get-ast-from-query"));
const types_1 = require("../types");
const cache_1 = __importDefault(require("../cache"));
const emitter_1 = __importStar(require("../emitter"));
const to_array_1 = require("../utils/to-array");
const env_1 = __importDefault(require("../env"));
const payload_1 = require("./payload");
const authorization_1 = require("./authorization");
const lodash_1 = require("lodash");
const translate_1 = require("../exceptions/database/translate");
const exceptions_1 = require("../exceptions");
const logger_1 = __importDefault(require("../logger"));
class ItemsService {
    constructor(collection, options) {
        this.collection = collection;
        this.knex = options.knex || database_1.default;
        this.accountability = options.accountability || null;
        this.eventScope = this.collection.startsWith('directus_') ? this.collection.substring(9) : 'items';
        this.schema = options.schema;
        return this;
    }
    /**
     * Create a single new item.
     */
    createOne(data, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyField = this.schema.collections[this.collection].primary;
            const fields = Object.keys(this.schema.collections[this.collection].fields);
            const aliases = Object.values(this.schema.collections[this.collection].fields)
                .filter((field) => field.alias === true)
                .map((field) => field.field);
            let payload = lodash_1.cloneDeep(data);
            // By wrapping the logic in a transaction, we make sure we automatically roll back all the
            // changes in the DB if any of the parts contained within throws an error. This also means
            // that any errors thrown in any nested relational changes will bubble up and cancel the whole
            // update tree
            const primaryKey = yield this.knex.transaction((trx) => __awaiter(this, void 0, void 0, function* () {
                // We're creating new services instances so they can use the transaction as their Knex interface
                const payloadService = new payload_1.PayloadService(this.collection, {
                    accountability: this.accountability,
                    knex: trx,
                    schema: this.schema,
                });
                const authorizationService = new authorization_1.AuthorizationService({
                    accountability: this.accountability,
                    knex: trx,
                    schema: this.schema,
                });
                // Run all hooks that are attached to this event so the end user has the chance to augment the
                // item that is about to be saved
                const hooksResult = yield emitter_1.default.emitAsync(`${this.eventScope}.create.before`, payload, {
                    event: `${this.eventScope}.create.before`,
                    accountability: this.accountability,
                    collection: this.collection,
                    item: null,
                    action: 'create',
                    payload,
                    schema: this.schema,
                    database: trx,
                });
                // The events are fired last-to-first based on when they were created. By reversing the
                // output array of results, we ensure that the augmentations are applied in
                // "chronological" order
                const payloadAfterHooks = hooksResult.length > 0 ? hooksResult.reverse().reduce((val, acc) => lodash_1.merge(acc, val)) : payload;
                const payloadWithPresets = this.accountability
                    ? yield authorizationService.validatePayload('create', this.collection, payloadAfterHooks)
                    : payloadAfterHooks;
                const { payload: payloadWithM2O, revisions: revisionsM2O } = yield payloadService.processM2O(payloadWithPresets);
                const { payload: payloadWithA2O, revisions: revisionsA2O } = yield payloadService.processA2O(payloadWithM2O);
                const payloadWithoutAliases = lodash_1.pick(payloadWithA2O, lodash_1.without(fields, ...aliases));
                const payloadWithTypeCasting = yield payloadService.processValues('create', payloadWithoutAliases);
                // In case of manual string / UUID primary keys, they PK already exists in the object we're saving.
                let primaryKey = payloadWithTypeCasting[primaryKeyField];
                try {
                    yield trx.insert(payloadWithoutAliases).into(this.collection);
                }
                catch (err) {
                    throw yield translate_1.translateDatabaseError(err);
                }
                // When relying on a database auto-incremented ID, we'll have to fetch it from the DB in
                // order to know what the PK is of the just-inserted item
                if (!primaryKey) {
                    // Fetching it with max should be safe, as we're in the context of the current transaction
                    const result = yield trx.max(primaryKeyField, { as: 'id' }).from(this.collection).first();
                    primaryKey = result.id;
                    // Set the primary key on the input item, in order for the "after" event hook to be able
                    // to read from it
                    payload[primaryKeyField] = primaryKey;
                }
                const { revisions: revisionsO2M } = yield payloadService.processO2M(payload, primaryKey);
                // If this is an authenticated action, and accountability tracking is enabled, save activity row
                if (this.accountability && this.schema.collections[this.collection].accountability !== null) {
                    const activityRecord = {
                        action: types_1.Action.CREATE,
                        user: this.accountability.user,
                        collection: this.collection,
                        ip: this.accountability.ip,
                        user_agent: this.accountability.userAgent,
                        item: primaryKey,
                    };
                    yield trx.insert(activityRecord).into('directus_activity');
                    const { id: activityID } = yield trx.max('id', { as: 'id ' }).from('directus_activity').first();
                    // If revisions are tracked, create revisions record
                    if (this.schema.collections[this.collection].accountability === 'all') {
                        const revisionRecord = {
                            activity: activityID,
                            collection: this.collection,
                            item: primaryKey,
                            data: JSON.stringify(payload),
                            delta: JSON.stringify(payload),
                        };
                        yield trx.insert(revisionRecord).into('directus_revisions');
                        const { id: revisionID } = yield trx.max('id', { as: 'id' }).from('directus_revisions').first();
                        // Make sure to set the parent field of the child-revision rows
                        const childrenRevisions = [...revisionsM2O, ...revisionsA2O, ...revisionsO2M];
                        if (childrenRevisions.length > 0) {
                            yield trx('directus_revisions').update({ parent: revisionID }).whereIn('id', childrenRevisions);
                        }
                        if (opts === null || opts === void 0 ? void 0 : opts.onRevisionCreate) {
                            opts.onRevisionCreate(revisionID);
                        }
                    }
                }
                return primaryKey;
            }));
            emitter_1.emitAsyncSafe(`${this.eventScope}.create`, {
                event: `${this.eventScope}.create`,
                accountability: this.accountability,
                collection: this.collection,
                item: primaryKey,
                action: 'create',
                payload,
                schema: this.schema,
                database: this.knex,
            });
            if (cache_1.default && env_1.default.CACHE_AUTO_PURGE && (opts === null || opts === void 0 ? void 0 : opts.autoPurgeCache) !== false) {
                yield cache_1.default.clear();
            }
            return primaryKey;
        });
    }
    /**
     * Create multiple new items at once. Inserts all provided records sequentially wrapped in a transaction.
     */
    createMany(data, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeys = yield this.knex.transaction((trx) => __awaiter(this, void 0, void 0, function* () {
                const service = new ItemsService(this.collection, {
                    accountability: this.accountability,
                    schema: this.schema,
                    knex: trx,
                });
                const primaryKeys = [];
                for (const payload of data) {
                    const primaryKey = yield service.createOne(payload, { autoPurgeCache: false });
                    primaryKeys.push(primaryKey);
                }
                return primaryKeys;
            }));
            if (cache_1.default && env_1.default.CACHE_AUTO_PURGE && (opts === null || opts === void 0 ? void 0 : opts.autoPurgeCache) !== false) {
                yield cache_1.default.clear();
            }
            return primaryKeys;
        });
    }
    /**
     * Get items by query
     */
    readByQuery(query, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const authorizationService = new authorization_1.AuthorizationService({
                accountability: this.accountability,
                knex: this.knex,
                schema: this.schema,
            });
            let ast = yield get_ast_from_query_1.default(this.collection, query, this.schema, {
                accountability: this.accountability,
                // By setting the permissions action, you can read items using the permissions for another
                // operation's permissions. This is used to dynamically check if you have update/delete
                // access to (a) certain item(s)
                action: (opts === null || opts === void 0 ? void 0 : opts.permissionsAction) || 'read',
                knex: this.knex,
            });
            if (this.accountability && this.accountability.admin !== true) {
                ast = yield authorizationService.processAST(ast);
            }
            const records = yield run_ast_1.default(ast, this.schema, {
                knex: this.knex,
                // GraphQL requires relational keys to be returned regardless
                stripNonRequested: (opts === null || opts === void 0 ? void 0 : opts.stripNonRequested) !== undefined ? opts.stripNonRequested : true,
            });
            if (records === null) {
                throw new exceptions_1.ForbiddenException();
            }
            return records;
        });
    }
    /**
     * Get single item by primary key
     */
    readOne(key, query, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            query = query !== null && query !== void 0 ? query : {};
            const primaryKeyField = this.schema.collections[this.collection].primary;
            const queryWithKey = Object.assign(Object.assign({}, query), { filter: Object.assign(Object.assign({}, (query.filter || {})), { [primaryKeyField]: {
                        _eq: key,
                    } }) });
            const results = yield this.readByQuery(queryWithKey, opts);
            if (results.length === 0) {
                throw new exceptions_1.ForbiddenException();
            }
            return results[0];
        });
    }
    /**
     * Get multiple items by primary keys
     */
    readMany(keys, query, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            query = query !== null && query !== void 0 ? query : {};
            const primaryKeyField = this.schema.collections[this.collection].primary;
            const queryWithKeys = Object.assign(Object.assign({}, query), { filter: {
                    _and: [
                        query.filter || {},
                        {
                            [primaryKeyField]: {
                                _in: keys,
                            },
                        },
                    ],
                } });
            const results = yield this.readByQuery(queryWithKeys, opts);
            return results;
        });
    }
    /**
     * Update multiple items by query
     */
    updateByQuery(query, data, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyField = this.schema.collections[this.collection].primary;
            const readQuery = lodash_1.cloneDeep(query);
            readQuery.fields = [primaryKeyField];
            // Not authenticated:
            const itemsService = new ItemsService(this.collection, {
                knex: this.knex,
                schema: this.schema,
            });
            // We read the IDs of the items based on the query, and then run `updateMany`. `updateMany` does it's own
            // permissions check for the keys, so we don't have to make this an authenticated read
            const itemsToUpdate = yield itemsService.readByQuery(readQuery);
            const keys = itemsToUpdate.map((item) => item[primaryKeyField]).filter((pk) => pk);
            return yield this.updateMany(keys, data, opts);
        });
    }
    /**
     * Update a single item by primary key
     */
    updateOne(key, data, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.updateMany([key], data, opts);
            return key;
        });
    }
    /**
     * Update many items by query
     */
    updateMany(keys, data, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyField = this.schema.collections[this.collection].primary;
            const fields = Object.keys(this.schema.collections[this.collection].fields);
            const aliases = Object.values(this.schema.collections[this.collection].fields)
                .filter((field) => field.alias === true)
                .map((field) => field.field);
            const payload = lodash_1.cloneDeep(data);
            const authorizationService = new authorization_1.AuthorizationService({
                accountability: this.accountability,
                knex: this.knex,
                schema: this.schema,
            });
            // Run all hooks that are attached to this event so the end user has the chance to augment the
            // item that is about to be saved
            const hooksResult = yield emitter_1.default.emitAsync(`${this.eventScope}.update.before`, payload, {
                event: `${this.eventScope}.update.before`,
                accountability: this.accountability,
                collection: this.collection,
                item: keys,
                action: 'update',
                payload,
                schema: this.schema,
                database: this.knex,
            });
            // The events are fired last-to-first based on when they were created. By reversing the
            // output array of results, we ensure that the augmentations are applied in
            // "chronological" order
            const payloadAfterHooks = hooksResult.length > 0 ? hooksResult.reverse().reduce((val, acc) => lodash_1.merge(acc, val)) : payload;
            if (this.accountability) {
                yield authorizationService.checkAccess('update', this.collection, keys);
            }
            const payloadWithPresets = this.accountability
                ? yield authorizationService.validatePayload('update', this.collection, payloadAfterHooks)
                : payloadAfterHooks;
            yield this.knex.transaction((trx) => __awaiter(this, void 0, void 0, function* () {
                const payloadService = new payload_1.PayloadService(this.collection, {
                    accountability: this.accountability,
                    knex: trx,
                    schema: this.schema,
                });
                const { payload: payloadWithM2O, revisions: revisionsM2O } = yield payloadService.processM2O(payloadWithPresets);
                const { payload: payloadWithA2O, revisions: revisionsA2O } = yield payloadService.processA2O(payloadWithM2O);
                const payloadWithoutAliasAndPK = lodash_1.pick(payloadWithA2O, lodash_1.without(fields, primaryKeyField, ...aliases));
                const payloadWithTypeCasting = yield payloadService.processValues('update', payloadWithoutAliasAndPK);
                if (Object.keys(payloadWithTypeCasting).length > 0) {
                    try {
                        yield trx(this.collection).update(payloadWithTypeCasting).whereIn(primaryKeyField, keys);
                    }
                    catch (err) {
                        throw yield translate_1.translateDatabaseError(err);
                    }
                }
                const childrenRevisions = [...revisionsM2O, ...revisionsA2O];
                for (const key of keys) {
                    const { revisions } = yield payloadService.processO2M(payload, key);
                    childrenRevisions.push(...revisions);
                }
                // If this is an authenticated action, and accountability tracking is enabled, save activity row
                if (this.accountability && this.schema.collections[this.collection].accountability !== null) {
                    const activityRecords = keys.map((key) => ({
                        action: types_1.Action.UPDATE,
                        user: this.accountability.user,
                        collection: this.collection,
                        ip: this.accountability.ip,
                        user_agent: this.accountability.userAgent,
                        item: key,
                    }));
                    const activityPrimaryKeys = [];
                    for (const activityRecord of activityRecords) {
                        yield trx.insert(activityRecord).into('directus_activity');
                        let primaryKey;
                        const result = yield trx.max('id', { as: 'id' }).from('directus_activity').first();
                        primaryKey = result.id;
                        activityPrimaryKeys.push(primaryKey);
                    }
                    if (this.schema.collections[this.collection].accountability === 'all') {
                        const itemsService = new ItemsService(this.collection, {
                            knex: trx,
                            schema: this.schema,
                        });
                        const snapshots = yield itemsService.readMany(keys);
                        const revisionRecords = activityPrimaryKeys.map((key, index) => ({
                            activity: key,
                            collection: this.collection,
                            item: keys[index],
                            data: snapshots && Array.isArray(snapshots) ? JSON.stringify(snapshots === null || snapshots === void 0 ? void 0 : snapshots[index]) : JSON.stringify(snapshots),
                            delta: JSON.stringify(payloadWithTypeCasting),
                        }));
                        for (let i = 0; i < revisionRecords.length; i++) {
                            yield trx.insert(revisionRecords[i]).into('directus_revisions');
                            const { id: revisionID } = yield trx.max('id', { as: 'id' }).from('directus_revisions').first();
                            if (opts === null || opts === void 0 ? void 0 : opts.onRevisionCreate) {
                                opts.onRevisionCreate(revisionID);
                            }
                            if (i === 0) {
                                // In case of a nested relational creation/update in a updateMany, the nested m2o/a2o
                                // creation is only done once. We treat the first updated item as the "main" update,
                                // with all other revisions on the current level as regular "flat" updates, and
                                // nested revisions as children of this first "root" item.
                                if (childrenRevisions.length > 0) {
                                    yield trx('directus_revisions').update({ parent: revisionID }).whereIn('id', childrenRevisions);
                                }
                            }
                        }
                    }
                }
            }));
            if (cache_1.default && env_1.default.CACHE_AUTO_PURGE && (opts === null || opts === void 0 ? void 0 : opts.autoPurgeCache) !== false) {
                yield cache_1.default.clear();
            }
            emitter_1.emitAsyncSafe(`${this.eventScope}.update`, {
                event: `${this.eventScope}.update`,
                accountability: this.accountability,
                collection: this.collection,
                item: keys,
                action: 'update',
                payload,
                schema: this.schema,
                database: this.knex,
            });
            return keys;
        });
    }
    /**
     * Upsert a single item
     */
    upsertOne(payload, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyField = this.schema.collections[this.collection].primary;
            const primaryKey = payload[primaryKeyField];
            const exists = primaryKey &&
                !!(yield this.knex
                    .select(primaryKeyField)
                    .from(this.collection)
                    .where({ [primaryKeyField]: primaryKey })
                    .first());
            if (exists) {
                return yield this.updateOne(primaryKey, payload, opts);
            }
            else {
                return yield this.createOne(payload, opts);
            }
        });
    }
    /**
     * Upsert many items
     */
    upsertMany(payloads, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeys = yield this.knex.transaction((trx) => __awaiter(this, void 0, void 0, function* () {
                const service = new ItemsService(this.collection, {
                    accountability: this.accountability,
                    schema: this.schema,
                    knex: trx,
                });
                const primaryKeys = [];
                for (const payload of payloads) {
                    const primaryKey = yield service.upsertOne(payload, { autoPurgeCache: false });
                    primaryKeys.push(primaryKey);
                }
                return primaryKeys;
            }));
            if (cache_1.default && env_1.default.CACHE_AUTO_PURGE && (opts === null || opts === void 0 ? void 0 : opts.autoPurgeCache) !== false) {
                yield cache_1.default.clear();
            }
            return primaryKeys;
        });
    }
    /**
     * Delete multiple items by query
     */
    deleteByQuery(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyField = this.schema.collections[this.collection].primary;
            const readQuery = lodash_1.cloneDeep(query);
            readQuery.fields = [primaryKeyField];
            // Not authenticated:
            const itemsService = new ItemsService(this.collection, {
                knex: this.knex,
                schema: this.schema,
            });
            const itemsToDelete = yield itemsService.readByQuery(readQuery);
            const keys = itemsToDelete.map((item) => item[primaryKeyField]);
            return yield this.deleteMany(keys);
        });
    }
    /**
     * Delete a single item by primary key
     */
    deleteOne(key, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deleteMany([key], opts);
            return key;
        });
    }
    /**
     * Delete multiple items by primary key
     */
    deleteMany(keys, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyField = this.schema.collections[this.collection].primary;
            if (this.accountability && this.accountability.admin !== true) {
                const authorizationService = new authorization_1.AuthorizationService({
                    accountability: this.accountability,
                    schema: this.schema,
                });
                yield authorizationService.checkAccess('delete', this.collection, keys);
            }
            yield emitter_1.default.emitAsync(`${this.eventScope}.delete.before`, {
                event: `${this.eventScope}.delete.before`,
                accountability: this.accountability,
                collection: this.collection,
                item: keys,
                action: 'delete',
                payload: null,
                schema: this.schema,
                database: this.knex,
            });
            yield this.knex.transaction((trx) => __awaiter(this, void 0, void 0, function* () {
                yield trx(this.collection).whereIn(primaryKeyField, keys).delete();
                if (this.accountability && this.schema.collections[this.collection].accountability !== null) {
                    const activityRecords = keys.map((key) => ({
                        action: types_1.Action.DELETE,
                        user: this.accountability.user,
                        collection: this.collection,
                        ip: this.accountability.ip,
                        user_agent: this.accountability.userAgent,
                        item: key,
                    }));
                    if (activityRecords.length > 0) {
                        yield trx.insert(activityRecords).into('directus_activity');
                    }
                }
            }));
            if (cache_1.default && env_1.default.CACHE_AUTO_PURGE && (opts === null || opts === void 0 ? void 0 : opts.autoPurgeCache) !== false) {
                yield cache_1.default.clear();
            }
            emitter_1.emitAsyncSafe(`${this.eventScope}.delete`, {
                event: `${this.eventScope}.delete`,
                accountability: this.accountability,
                collection: this.collection,
                item: keys,
                action: 'delete',
                payload: null,
                schema: this.schema,
                database: this.knex,
            });
            return keys;
        });
    }
    /**
     * Read/treat collection as singleton
     */
    readSingleton(query, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            query = lodash_1.clone(query);
            query.limit = 1;
            const records = yield this.readByQuery(query, opts);
            const record = records[0];
            if (!record) {
                let fields = Object.entries(this.schema.collections[this.collection].fields);
                const defaults = {};
                if (query.fields && query.fields.includes('*') === false) {
                    fields = fields.filter(([name]) => {
                        return query.fields.includes(name);
                    });
                }
                for (const [name, field] of fields) {
                    defaults[name] = field.defaultValue;
                }
                return defaults;
            }
            return record;
        });
    }
    /**
     * Upsert/treat collection as singleton
     */
    upsertSingleton(data, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyField = this.schema.collections[this.collection].primary;
            const record = yield this.knex.select(primaryKeyField).from(this.collection).limit(1).first();
            if (record) {
                return yield this.updateOne(record[primaryKeyField], data, opts);
            }
            return yield this.createOne(data, opts);
        });
    }
    create(data, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.warn('ItemsService.create is deprecated and will be removed before v9.0.0. Use createOne or createMany instead.');
            if (Array.isArray(data))
                return this.createMany(data, opts);
            return this.createOne(data, opts);
        });
    }
    readByKey(key, query = {}, action = 'read') {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.warn('ItemsService.readByKey is deprecated and will be removed before v9.0.0. Use readOne or readMany instead.');
            if (Array.isArray(key)) {
                return this.readMany(key, query, { permissionsAction: action });
            }
            else {
                return this.readOne(key, query, { permissionsAction: action });
            }
        });
    }
    update(data, key) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.warn('ItemsService.update is deprecated and will be removed before v9.0.0. Use updateOne or updateMany instead.');
            const primaryKeyField = this.schema.collections[this.collection].primary;
            if (key) {
                data = Array.isArray(data) ? data[0] : data;
                if (Array.isArray(key))
                    return yield this.updateMany(key, data);
                else
                    return yield this.updateOne(key, data);
            }
            const keys = [];
            yield this.knex.transaction((trx) => __awaiter(this, void 0, void 0, function* () {
                const itemsService = new ItemsService(this.collection, {
                    accountability: this.accountability,
                    knex: trx,
                    schema: this.schema,
                });
                const payloads = to_array_1.toArray(data);
                for (const single of payloads) {
                    const payload = lodash_1.clone(single);
                    const key = payload[primaryKeyField];
                    if (!key) {
                        throw new exceptions_1.InvalidPayloadException('Primary key is missing in update payload.');
                    }
                    keys.push(key);
                    yield itemsService.updateOne(key, payload);
                }
            }));
            return keys;
        });
    }
    upsert(data) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.warn('ItemsService.upsert is deprecated and will be removed before v9.0.0. Use upsertOne or upsertMany instead.');
            if (Array.isArray(data))
                return yield this.upsertMany(data);
            return yield this.upsertOne(data);
        });
    }
    delete(key) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.warn('ItemsService.delete is deprecated and will be removed before v9.0.0. Use deleteOne or deleteMany instead.');
            if (Array.isArray(key))
                return yield this.deleteMany(key);
            else
                return yield this.deleteOne(key);
        });
    }
}
exports.ItemsService = ItemsService;
